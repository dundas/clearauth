/**
 * Database Schema Types
 *
 * TypeScript interfaces and Kysely types for the mech-auth database schema.
 * These types must match the SQL schema defined in the migration files.
 *
 * @see /migrations/001_create_users_table.sql
 * @see /migrations/002_create_sessions_table.sql
 * @see /migrations/003_create_verification_tokens.sql
 * @see /migrations/004_create_reset_tokens.sql
 * @see /migrations/005_create_magic_link_tokens.sql
 * @see /migrations/006_create_refresh_tokens.sql
 * @see /migrations/007_create_devices_table.sql
 * @see /migrations/008_create_challenges_table.sql
 */

import type { ColumnType, Selectable, Insertable, Updateable } from 'kysely'

/**
 * Users Table
 *
 * Core users table with support for email/password and OAuth authentication.
 */
export interface UsersTable {
  id: ColumnType<string, string | undefined, never> // UUID, generated on insert
  email: string
  email_verified: ColumnType<boolean, boolean | undefined, boolean> // Default: false
  password_hash: string | null // NULL for OAuth-only users

  // OAuth provider IDs
  github_id: string | null
  google_id: string | null
  discord_id: string | null
  apple_id: string | null
  microsoft_id: string | null
  linkedin_id: string | null
  meta_id: string | null

  // User profile
  name: string | null
  avatar_url: string | null

  // Timestamps
  created_at: ColumnType<Date, Date | undefined, never> // Default: NOW()
  updated_at: ColumnType<Date, Date | undefined, Date> // Auto-updated via trigger
}

/**
 * Sessions Table
 *
 * Session management with expiration tracking.
 * Session IDs are generated by the application using Oslo.
 */
export interface SessionsTable {
  id: string // Random session ID (generated by Oslo)
  user_id: string // UUID foreign key to users
  expires_at: Date
  ip_address: string | null
  user_agent: string | null
  created_at: ColumnType<Date, Date | undefined, never> // Default: NOW()
}

/**
 * Email Verification Tokens Table
 *
 * Tokens for email verification flow.
 * Typically expire after 24 hours.
 */
export interface EmailVerificationTokensTable {
  token: string // Random token (generated by Oslo)
  user_id: string // UUID foreign key to users
  email: string // Email being verified
  expires_at: Date
  created_at: ColumnType<Date, Date | undefined, never> // Default: NOW()
}

/**
 * Password Reset Tokens Table
 *
 * Tokens for password reset flow.
 * Typically expire after 1 hour for security.
 */
export interface PasswordResetTokensTable {
  token: string // Random token (generated by Oslo)
  user_id: string // UUID foreign key to users
  expires_at: Date
  created_at: ColumnType<Date, Date | undefined, never> // Default: NOW()
}

/**
 * Magic Link Tokens Table
 *
 * Tokens for passwordless authentication via email magic links.
 * Typically expire after 10-15 minutes for security.
 * One-time use - deleted after successful consumption.
 */
export interface MagicLinkTokensTable {
  token: string // Random token (generated by Oslo)
  user_id: string // UUID foreign key to users
  email: string // Email for audit/debugging
  return_to: string | null // Optional redirect URL after login
  expires_at: Date
  created_at: ColumnType<Date, Date | undefined, never> // Default: NOW()
}

/**
 * Refresh Tokens Table
 *
 * JWT refresh tokens for long-lived authentication.
 * Tokens are hashed (SHA-256) before storage for security.
 * Support revocation and expiration tracking.
 * Typically expire after 30 days.
 */
export interface RefreshTokensTable {
  id: ColumnType<string, string | undefined, never> // UUID, generated on insert
  user_id: string // UUID foreign key to users
  token_hash: string // SHA-256 hash of refresh token
  name: string | null // User-friendly label (e.g., "MacBook Pro")
  expires_at: Date
  revoked_at: Date | null // NULL = active, non-NULL = revoked
  created_at: ColumnType<Date, Date | undefined, never> // Default: NOW()
  last_used_at: Date | null // Updated on token refresh
}

/**
 * Devices Table
 *
 * Hardware-backed device keys for phishing-resistant authentication.
 * Supports Web3 wallets (MetaMask, SeedID), iOS (Secure Enclave), Android (KeyStore).
 * Each device has unique cryptographic key pair stored in hardware.
 */
export interface DevicesTable {
  id: ColumnType<string, string | undefined, never> // UUID, generated on insert
  device_id: string // Unique device identifier
  user_id: string // UUID foreign key to users
  platform: string // 'web3' | 'ios' | 'android'
  public_key: string // Public key (format depends on key_algorithm)
  wallet_address: string | null // For Web3 only (Ethereum address)
  key_algorithm: string // 'secp256k1' | 'Ed25519' | 'P-256'
  status: ColumnType<string, string | undefined, string> // 'active' | 'revoked', default: 'active'
  registered_at: Date
  last_used_at: Date | null // Updated on each authenticated request
  created_at: ColumnType<Date, Date | undefined, never> // Default: NOW()
}

/**
 * Challenges Table
 *
 * Nonce-based challenges for replay-proof device authentication.
 * Challenges expire after 10 minutes and can only be used once.
 * Automatically cleaned up via TTL or scheduled job.
 */
export interface ChallengesTable {
  nonce: string // Primary key - unique random nonce (32 bytes hex)
  challenge: string // Full challenge string (nonce|timestamp)
  created_at: Date
  expires_at: Date // Challenges expire after 10 minutes
}

/**
 * Database Schema
 *
 * Complete database schema for Kysely type-safe queries.
 */
export interface Database {
  users: UsersTable
  sessions: SessionsTable
  email_verification_tokens: EmailVerificationTokensTable
  password_reset_tokens: PasswordResetTokensTable
  magic_link_tokens: MagicLinkTokensTable
  refresh_tokens: RefreshTokensTable
  devices: DevicesTable
  challenges: ChallengesTable
}

/**
 * Type-safe row types for SELECT queries
 */
export type User = Selectable<UsersTable>
export type Session = Selectable<SessionsTable>
export type EmailVerificationToken = Selectable<EmailVerificationTokensTable>
export type PasswordResetToken = Selectable<PasswordResetTokensTable>
export type MagicLinkToken = Selectable<MagicLinkTokensTable>
export type RefreshToken = Selectable<RefreshTokensTable>
export type Device = Selectable<DevicesTable>
export type Challenge = Selectable<ChallengesTable>

/**
 * Type-safe input types for INSERT queries
 */
export type NewUser = Insertable<UsersTable>
export type NewSession = Insertable<SessionsTable>
export type NewEmailVerificationToken = Insertable<EmailVerificationTokensTable>
export type NewPasswordResetToken = Insertable<PasswordResetTokensTable>
export type NewMagicLinkToken = Insertable<MagicLinkTokensTable>
export type NewRefreshToken = Insertable<RefreshTokensTable>
export type NewDevice = Insertable<DevicesTable>
export type NewChallenge = Insertable<ChallengesTable>

/**
 * Type-safe input types for UPDATE queries
 */
export type UserUpdate = Updateable<UsersTable>
export type SessionUpdate = Updateable<SessionsTable>
export type EmailVerificationTokenUpdate = Updateable<EmailVerificationTokensTable>
export type PasswordResetTokenUpdate = Updateable<PasswordResetTokensTable>
export type MagicLinkTokenUpdate = Updateable<MagicLinkTokensTable>
export type RefreshTokenUpdate = Updateable<RefreshTokensTable>
export type DeviceUpdate = Updateable<DevicesTable>
export type ChallengeUpdate = Updateable<ChallengesTable>

/**
 * User with session information (common join result)
 */
export interface UserWithSession {
  user: User
  session: Session
}

/**
 * Public user profile (safe to expose to client)
 */
export interface PublicUser {
  id: string
  email: string
  email_verified: boolean
  name: string | null
  avatar_url: string | null
  created_at: Date
}

/**
 * Session with user information (common join result)
 */
export interface SessionWithUser {
  session: Session
  user: PublicUser
}

/**
 * Check if a magic link token is valid (not expired)
 */
export function isValidMagicLinkToken(token: MagicLinkToken): boolean {
  return token.expires_at > new Date()
}

/**
 * Helper function to convert User to PublicUser
 */
export function toPublicUser(user: User): PublicUser {
  return {
    id: user.id,
    email: user.email,
    email_verified: user.email_verified,
    name: user.name,
    avatar_url: user.avatar_url,
    created_at: user.created_at,
  }
}

/**
 * Type guards
 */
export function isValidSession(session: Session): boolean {
  return new Date(session.expires_at) > new Date()
}

export function isValidEmailVerificationToken(token: EmailVerificationToken): boolean {
  return new Date(token.expires_at) > new Date()
}

export function isValidPasswordResetToken(token: PasswordResetToken): boolean {
  return new Date(token.expires_at) > new Date()
}

/**
 * Check if a refresh token is valid (not expired and not revoked)
 */
export function isValidRefreshToken(token: RefreshToken): boolean {
  const now = new Date()
  return new Date(token.expires_at) > now && token.revoked_at === null
}

/**
 * Check if a device is valid (status is 'active')
 */
export function isValidDevice(device: Device): boolean {
  return device.status === 'active'
}

/**
 * Check if a challenge is valid (not expired)
 */
export function isValidChallenge(challenge: Challenge): boolean {
  return new Date(challenge.expires_at) > new Date()
}
